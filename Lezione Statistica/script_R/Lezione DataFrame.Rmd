---
title: "Lezione Software R"
author: "Dr. Francesco Calabrese"
date: "16/3/2022"
output: 
  slidy_presentation:
    css: style.css
---

```{r setup, include=F}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  dev = "svg",
  fig.width = 12,
  fig.height = 7, size = "tiny", collapse=T, comment="#"
)

```

```{r}
library(tidyverse)
femmine <- read.csv("Cartella dove salvare DF\\femmine.txt", header = F, sep = " ")

colnames(femmine) <- c("ASL","Anno 2001", "Anno 2002", "Anno 2003",
                      "Anno 2004", "Anno 2005", "Anno 2006", "Anno 2007",
                      "trend")

femmine <- pivot_longer(data = femmine,
                       starts_with("Anno"),
                       names_to = "Coorte", 
                       values_to = "Percentuale")

femmine$Percentuale = gsub(",", ".",femmine$Percentuale)
femmine$Percentuale = as.numeric(femmine$Percentuale)

```

---

<h1>Le <span>Basi</span></h1>
<hr>

-   Variabili
-   Gli operatori più utili
-   Le funzioni
-   Vettori
-   Matrici
-   DataFrame
-   Liste (la cosa più complessa di R)

---

<h2>Le<span> Variabili</span></h2>
<hr>

Qualunque elemento che occupa memoria del computer è una variabile.

<h3>Tipi di Variabile</h3>

-   Numerica (6, -3, 2.5, pi)
-   Stringa ("ciao", "F", "4.4")
-   Categorica (F, M, diploma, laurea, master)
-   Booleana (TRUE, FALSE)
-   Nulla (NA)

---

<h2>Gli <span>Operatori</span></h2>
<hr>
<div style="clear: none;" >
<div style="float: left; width: 48%;">
```{r eval=T, echo=T}
# Somma : +
10 + 3
# Sottrazione : -
3 - 6
# Moltiplicazione : *
3 * 3
# Numero Assoluto : abs
abs(-12)
#Parentesi : SOLO ()
(3+5)*6
# Il segno <- serve per 
#assegnare un valore
numeri <- c(1, 2, 3)
#Parentesi quadra : funzione 
#[] di selezione
numeri[1]
```

</div>
<div style="float: right; width: 48%;">

```{r eval=T, echo=T}
# Divisione : FRONT-SLASH
10/2
# Potenza : **
3**3
# Resto : %%
34 %% 3
# E' contenuto : %in%
2 %in% c(3, 4, 5, 6, 2)
#Maggiore : >   
3>7
#Minore : <  
3<7
#Uguale : ==
3==4
```

</div>
</div>

---

<h2>Gli Operatori<span>If Else While</span></h2>
<hr>
<div style="clear: none;" >
<div style="float: left; width: 48%;">
La struttura è sempre fatta da:<br>- if<br>- (condizione)<br>- {cosadeve fare il programma}
```{r, echo=T, eval=T, comment="#"}
#Se è vero : if  
#Altrimenti : else
numero = 3
if (numero == 3){
  print("Si")
} else {
    print("No")
}
numero = 4
if (numero == 3){
  print("Si")
} else {
    print("No")
  }
```

</div>
<div style="float: right; width: 48%;">
La struttura è sempre fatta da: <br>- while<br>- (condizione)<br>- {cosadeve fare il programma}
```{r, echo=T, eval=T, comment="#"}
#Assegno a numero il valore 9
numero = 9 
#Verifico che la sua radice si intera
sqrt(numero)!=round(sqrt(numero))
numero = 12
sqrt(numero)!=round(sqrt(numero))

numero = 22

while(sqrt(numero)!=round(sqrt(numero))){
  numero = numero + 1
  print(numero)
}
```
</div>
</div>

---

<h2>Le<span> Funzioni</span></h2>
<hr>
Le funzioni sono degli algoritmi che accettano uno o più argomenti e restituiscono un risultato.<br>
La maggior parte delle funzioni che si impiegano su R sono già state create, nulla vieta però di costruirne altre.<br>
In R è necessario dare un nome alla propria funzione tranne che in particolari situazioni.<br>
<h3>Esempio:</h3>

```{r, echo=T, eval=T, comment="#"}
#sum() è una funzione intrinseca ad R che prende un 
#numero n di argomenti numerici

sum(4.5, 4, 3.65, 32, -10)

#Creo una funzione con il comando function() che accetta 
#un nome e che restituisce una stringa dove la 
#persona viene salutata

saluta <- function(nome){
  
  print(paste('Ciao', nome))
}

#Importante: l'argomento deve essere tra virgolette;
#in altre parole deve essere una stringa!

saluta("Antonio")

```

---


Una funzione può prendere diversi argomenti, sono molto importanti il **nome** dell'argomento e la **posizione**!

```{r, echo=T, eval=T, comment="#"}

saluta <- function(nome, cognome, eta){
  
  print(paste('Ciao', nome, cognome, 'la tua età è', eta, 'anni'))
}

#Se do il nome degli argomenti questo prevale sulla posizione

saluta("Marco", "Rossi", 32)

saluta(cognome = 'Rossi', eta = 32, nome = 'Marco')

```

---

Tutto ciò che viene creato all'interno di una funzione non va nell'ambiente di lavoro a meno che non lo si espliciti nella funzione stessa.<br>
```{r, echo=T, eval=T, warning=TRUE}

moltiplicazione <- function(a, b){
  c = a*b
}
moltiplicazione(2, 3)
print(c) #Non restituisce nulla perchè è interno alla funzione

moltiplicazione <- function(a, b){
  c = a*b
  return(c)
}
moltiplicazione(2, 3)
```
Perchè la funzione restituisca una variabile nell' ambiente di lavoro è necessario usare la funzione <mark>return()</mark>.

---

<h2>I<span> Vettori</span></h2>
<hr>

Insieme  **ordinato** di variabili **tutte** dello stesso tipo.<br>

Non possono esistere vettori che hanno variabili di tipo diverso al loro
interno. <br>

Fa eccezione la variabile **Nulla o NA** che può essere contenuta in
qualsiasi vettore.<br>

Esistono quindi 4 tipi di vettori:<br>

- numerico 
- stringa
- booleano
- categorico

---

<h2>Creare un <span>Vettore</span></h2>
<hr>

Il comando per creare un vettore è **c()**, ogni elemento deve essere separato dalla virgola.<br>Per assegnare un nome ad ogni elemento è necessario usare il segno **=**, scrivendo il nome a sinistra ed il valore a destra.

```{r, echo=T, eval=T, comment="#"}
vettore_numerico <- c(1, 2, 3)
vettore_stringa <- c("ciao", "mi", "chiamo", "Francesco")
vettore_booleano <- c(TRUE, FALSE, TRUE, FALSE,TRUE, FALSE)
vettore_categorico <- as.factor(c("M", "F", "M", "M", "F"))

#Creo un vettore dove ogni variabile ha un nome
studenti <-c("Studente1"="Carlo", "Studente2"="Paolo", 
             "Studente3"="Anna", "Studente4"="Ada", 
             "Studente5"="Pippo")

#Richiamo i nomi con la funzione names()
names(studenti)
studenti
vettore_categorico
vettore_numerico
```
In R è meglio usare il segno **<-** al posto del segno **=**, quest'ultimo va riservato ad alcuni comandi particaolari

---

<h2>Le <span>Matrici</span></h2>
<hr>

Le matrici sono delle griglie che si sviluppano su *n* dimensioni.<br>

Classicamente le matrici hanno 2 dimensioni, ma potenzialmente possono
essere sviluppate su un numero di dimensioni più piccolo o più
grande. 

<h2>Per <span>Semplificare</span></h2>
- Il vettore è una matrice unidimensionale<br>
- La scacchiera è una matrice bidimensionale (classica)<br>
- Lo spazio si può rappresentare su una matrice tridimensionale<br>
- Lo spazio-tempo si può rappresentare su una matrice quadridimensionale...

---

<h2>Creare una <span>matrice</span></h2>
<hr>

In **R** le matrici sono bidimensionali, e si possono creare con vari
sistemi.<br>Il comando principale è **matrix()**, ma se generiamo la
matrice da più vettori possiamo usare i comandi **cbind() o
rowbind()**.<br>
Il comando **matrix()** dispone gli elementi di un *set di valori* a formare una griglia di 2 dimensioni: **Righe e Colonne**


```{r, echo=T, eval=T}
#Userò il vettore booleano creato in precedenza:

matrice <- matrix(vettore_booleano, 2, 3)

#Ho creato così una matrice di 2 righe e 3 colonne

matrice
```

---

<h2>Alternative per creare <span>matrici</span></h2>
<hr>

Matrici e vettori sono fra di loro correlate a tal punto più vettori possono essere uniti a formare matrici.

```{r eval=T, echo=T}
a <- c(1, 2, 3)
b <- c(4, 5, 6)
c <- c(7, 8, 9)
matrice <- cbind(a, b, c)
matrice 
matrice2 <- rbind(a, b, c) 
matrice2 
typeof(matrice)

```

---

<h2>Le <span>matrici</span> sono simili ai <span>vettori</span></h2>
<hr>

Non è possibile creare una matrice che contiene variabili di tipo diverso.<br>
In ciò le matrici si comportano esattamente come i vettori.<br>
```{r eval=T, echo=T}
a <- cbind(matrice2, c(TRUE, FALSE, FALSE))
b <- cbind(matrice2, c("T", "F", "F"))
a
b
typeof(a)
typeof(b)
```

---

<h2>Le <span>Liste</span></h2>
Le Liste in R sono oggetti che possono contenere di tutto al loro interno.<br>
Di conseguenza all'interno delle liste possono essere presenti variabili singole, vettori, liste, matrici, dataframe, ma anche funzioni.<br>
Ad esempio tutti i file che permettono di creare mappe su R sono delle liste perchè all'interno di queste dobbiamo trovare il nome della regione geografica (comune, provincia, regione, stato), altre informazioni aggiuntive (popolazione, tipo di zona geografica) ed infine le coordinate che sono organizzate in modo tale che possano essere proiettate su di un piano cartesiano.

```{r eval=T, echo=T}
#Creo una lista con 3 vettori e 2 matrici
lista <- list(matrice, matrice2)
#Richiamo il 2 elemento
lista[2]
#Riciamo l'elemento nella riga 2 colonna 2 del secondo elemento
lista[[2]][2, 2]
```

---

<h2>Le <span>coordinate</span> e i <span>metadati</span></h2>
<hr>

E' possibile attribuire ad ogni oggetto di R vari metadati che permettono di lavorare meglio con l'oggetto.\n
Sappiamo già che ogni oggetto ha un nome, questo non è nient'altro che un metadato.\n
<br>
Nell'analisi dati i metadati più importanti sono rappresentati dalla posizione degli elementi contenuti nei nostri oggetti.\n
Infatti tutti gli elementi di R sono contenitori o cassetti che contengono dati.\n
Ogni dato ha una sua specifica posizione e questa può essere identificata.\n

```{r eval=T, echo=T}
a <- c(9, 8, 7, 6, 5, 4, 3, 2, 1)
#Uso la funzione [] per selezionare uno o più specifici elementi del vettore
a[3]
a[c(1, 4, 8)]

#E' possibile anche selezionare gli elementi in base ad una loro caratteristica
#Per esempio per sapere se un numero è pari posso
#usare il comando per ottenere il resto della divisione (%%)

a %% 2 == 0
#Ora invece di una posizione cercherò i numeri con una 
#formula che restituisce vero e falso

a[a %% 2 == 0]

```
---

<h2>Coordinate delle <span>matrici</span> e dei <span>Dataframe</span></h2>
<hr>

Lo stesso principio si può applicare alle matrici che però sono bidimensionali.<br>
La regola aurea per identificare un dato in una specifica posizione è: **riga e colonna**. <br>
Quindi nella nostra funzione di selezione indicheremo prima le righe e poi le colonne.<br>

```{r eval=T, echo=T}
matrice <- matrix(c(1:100), 10, 10)
matrice

#Se voglio che la funzione di selezione mi restituisca 99 scriverò:

matrice[9, 10]

```

---

<h2>Differenze fra <span>matrici</span> e <span>Dataframe</span></h2>
<hr>

:::: {.columns}
::: {.column width=40%}
<h3><span>Matrici</span></h3>
- Contine solo un tipo di variabile
- Solitamente è usata per calcoli matematici
- Scarsa utilità nell'analisi dati
- Utile per alcune attività (Machine Learning)
<br>
```{r eval=T, echo=F}
matrice2
```
:::
::: {.column width=60%}
<h3><span>Dataframe</span></h3>
- Può contenere tutti i tipi di variabili
- Utile per raccogliere informazioni 
- Strumento essenziale nell' analisi dati
- Meno versatile per l'uso di alcuni pacchetti in R
<br>
<br>

<img img src="Immagini/database.gif" alt="Database"></img>
:::
::::

---

<h2>Importare un <span>Dataframe</span></h2>
<hr>
Se ci sono problemi a capire in che directory si sta lavorando si può lanciare la funzione <mark>getwd()</mark>.<br>
R può leggere qualunque formato, ma per fortuna nella maggior parte dei casi è possibile ottenere i dati in formato *.csv* o *.txt*.<br>
La libreria <mark>Tidyverse</mark> contiene delle funzioni che consentono di leggere i file Excel, ma è preferibile salvarsi i file in Excel direttamente in formato *.csv*.<br>
R ha delle funzioni intrinseche per importare i file *.txt o csv*.
<br>
```{r eval=T, echo=T}
#Scelgo il percorso del file ed il file,
#inoltre fornisco l'argomento separatore che mi
#identifica il modo in cui le variabili sono separate.

data <- read.csv(file = 'Cartella dove salvare DF\\fev.csv', sep = '')

head(data)
```
<br>
Importante:<br>
Su Windows il percorso file si indica col back-slash (\\), ma purtoppo il back-slash è un carattere speciale in R! <br>
In particolare il back-slash permette di skippare i caratteri speciali quindi, per riassumere per scrivere un back-slash in R bisogna scriverne due.<br>

---

<h2>Studiare un <span>Dataframe</span></h2>
<hr>
Quando si estraggono i dati dalle piattaforme online o dai datawarehouse delle Aziende Sanitarie di solito contengono tantissime informazioni ridondanti (es. ASL e codice ASL). Nella maggior parte dei casi sono database dove non viene definita la natura delle variabili che sono quindi in formato stringa.<br>
<br>
Il comando <mark>view()</mark> o <mark>View()</mark> permette di visualizzare il database, mentre il comando <mark>summary()</mark> permette di riassumere le variabili del DF.

```{r eval=T, echo=T}
summary(data)
```

---

In questo caso il database é molto semplice ed è costituito da ```r ncol(data)``` colonne e ```r nrow(data)``` righe. <br>
Il genere e il fumo sono però variabili categoriche e quindi dobbiamo cambiarle con la funzione <mark>as.factor()</mark>. <br>
Il segno del dollaro ($) in R viene usato per fare riferimento ad una colonna specifica del datafasme.

```{r eval=T, echo=T}
data$sex <- factor(data$sex)

data$smoke <- factor(data$smoke,
                     levels = c('current smoker', 'non-current smoker'),
                     labels = c('Yes', 'No'))

table(data$smoke)
```
:::: {.columns}
::: {.column width=50%}
<h3>Analisi grafica variabile quantitativa</h3>
<br>
```{r eval=T, echo=F}
hist(data$age ,c(seq(0, 20, 2)),main="Distrubuzione Età",xlab="Età")
```
:::
::: {.column width=50%}
<h3>Analisi variabile categorica</h3>
<br>
```{r eval=T, echo=F}
plot(data$smoke, data$fev, xlab="Smoke",
     ylab="Fev",main = "Correlazione fumo e Fev")
```
:::
::::

---

<h2>Introduzione al <span>Tidyverse</span></h2>
<hr>
Tidyverse e un modulo di R che contiene sotto-moduli ognuno dei quali è utile nell'analisi dati:<br>
- readr (utile per leggere file creati con excel o altri programmi)<br>
- string (gestione delle stringhe)<br>
- dplyr (modifica dei Dataframe e 'pipe')<br>
- tidyr (gestione e oraganizzazione Dataframe)<br>
- ggplot (grafici)<br>
- purr (gestione delle funzioni iterative)<br>

```{r eval=T, echo=T, message=TRUE, warning=TRUE}

#install.packages("tidyverse")

library(tidyverse)
```

<a href="https://www.tidyverse.org/packages/">
   <img src="Immagini/tidyverse.jpg" alt="Tidyverse">
</a>

---

<h2>Gestione delle <span>Stringhe</span></h2>
<hr>
R garantisce la più completa gestione delle stringhe, sostanzialmente qualsiasi modifica che si vuole apportare ad una stringa si può fare con R. <br>

<h3><span>str_detect</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
nomi <- c('Marco', 'Anna', 'giulio', 
          'Francesco', 'Maria', 'Concetta', 
          'Anna Maria', 'Mirko', 'Marco')
str_detect(nomi, 'nn')
nomi[str_detect(nomi, 'nn')]
```
<h3><span>str_ends e str_start</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
str_ends(nomi, 'o')
str_starts(nomi, 'M')
nomi[str_ends(nomi, 'o')]
nomi[str_starts(nomi, 'M')]
```
<h3><span>str_to_lower str_to_upper e str_to_title</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
str_to_lower(nomi)
str_to_upper(nomi)
str_to_title(nomi)
```

---

<h3><span>str_count e str_c</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
vettore_stringa

str_count(vettore_stringa)
str_c(vettore_stringa, collapse = ' ')
```

<h3><span>gsub e str_replace</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#Rimuovo tutte le vocali

#Metodo base
gsub('[aeiouAEIOU]', '*', vettore_stringa)

#Metodo pacchetto string
str_replace_all(vettore_stringa, '[aeiouAEIOU]', '*')
```

---

<h3><span>str_subset</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
str_subset(nomi, 'ar', negate = F)
```
<h3>Operazioni più <span>complesse</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
str_to_lower(str_extract(nomi, '^.'))

#Se volessi creare delle mail potrei usare la funzione paste0()

paste0(str_to_lower(str_extract(nomi, '^.')), '@uniqualcosa.it')

#Ma cosi i doppi nomi vengono persi, la soluzione é un po' complessa

paste0(
  str_to_lower(
    sapply(
      sapply(
        sapply(
        nomi,
        str_split,
        ' ',
        simplify = T,
        USE.NAMES = F),
        str_extract, '^.'),
      str_c, collapse = '')
    ), 
  '@uniqualcosa.it'
  )

```

---

<h1>Le Regular <span>Expressions</span></h1>
<hr>
Alcuni caratteri in R sono speciali e non possono perciò essere riportati come tali nelle quando una stringa viene restituita dalla console.<br>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
stringa <- "Ciao\nSono andato a capo, \" \\"
print(stringa)

#Il comando writeLine mi permette di vedere la stringa come una regular 
#expression e cioè come la vede il computer
writeLines(stringa)
writeLines("\\\\")
stringa <- c("ab", "a.b", "aabb")
str_subset(stringa, '\\.')
```

---

<h3>Simbolo <span>backslash</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
stringa <- c("ab", "a.b", "aabb", "a\b", "a\\b", "bbaba")
#Il punto significa: qualunque carattere 
str_subset(stringa, '.a.')
#Se voglio identificare un backslash devo usare per forza il carattere speciale
str_subset(stringa, 'a\b')
#Per identificare 2 backslash ne devo usare 4
str_subset(stringa, '\\\\')
```
<h3>Simboli <span>^ e $</span></h3>

```{r eval=T, echo=T, message=TRUE, warning=TRUE}
stringa <- c("banana", "mela", "mele", "torta di mele", "melevisione")
#Con ^ si indica: INIZIA, con $ si indica : FINISCE
str_subset(stringa, "mel")
str_subset(stringa, "^mel")
str_subset(stringa, "mele$")
str_subset(stringa, "^mele$")
```

---

<h3>Simboli <span>backslash(d o s) [..] e [^]</span></h3>

```{r eval=T, echo=T, message=TRUE, warning=TRUE}
stringa <- c("Slipknot", "A Day to Remember", "Green Day", "Sum41", "Blink182")
#\d seleziona tutto ciò che ha numeri dentro
str_subset(stringa, "\\d")
#\s seleziona tutto quello che ha uno spazio bianco
str_subset(stringa, "\\s")
#[...] seleziona tutto ciò che è in parentesi
str_subset(stringa, "[pkn]")
#[^...] seleziona tutto tranne quello che è fra parentesi
str_subset(stringa, "[^Slipknot]")
str_subset(stringa, "A[ ]")
```

---

<h3>Operatori <span>logici</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#E' possibile usare gli operatori logici nella analisi delle stringhe
comuni <- c("Ciriè", "Cirié", "Cirie'", "Egne'", "Egnè", "Moncalieri")
#Questa situazione è molto problematica perchè per il computer
#è come avere 4 comuni distinti!
str_subset(comuni, "Ciri(e\\'|é|è)")
#Ma si può fare di meglio
str_subset(comuni, ".(e\\'|é|è|e)$")
#Ed ora posso omologare tutto! Con la funzione gsub()
gsub("(e\\'|é|è|e)$", "è" , str_subset(comuni, ".(e\\'|é|è|e)$"))
```

---

<h3>Le squenze che si <span>ripetono</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
# ? trova corrispondanza con l'elemento precedente 0 o 1 volta

stringa <- c("ran", "rain", "train", "rn", "raiin")

str_extract(stringa, "rai?n")
str_subset(stringa, "rai?n")

# + trova corrispondanza con l'elemento precedente 1 o più volta
str_extract(stringa, "rai+n")
str_subset(stringa, "rai+n")
# * trova corrispondanza con l'elemento precedente 0, 1 o più volta
str_extract(stringa, "rai*n")
str_subset(stringa, "rai*n")
str_subset(stringa, "r(ai)*n")

```

---

<h3>Le squenze che si <span>Ripetono</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}

# {numero minimo, numeromassimo} trova corrispondanza solo con i valori dati
stringa <- c("ran", "rain", "train", "rn", "raiin", "raiiin")

str_subset(stringa, "rai{1,2}n")

#Con il backslash posso selezzionare sequenze che si ripetono
#é possibile mettere fra parentesi una sequenza e vedere quante volte si ripete
stringa <- c("banana", "cocco", "papaia", "pappa", "tartare","osso", "peppa")

# Riconosci qualunque lettera che si ripete dopo
str_extract(stringa, "(.)\\1")
#Riconosci 2 lettere che si ripetono dopo una lettera qualunque
str_extract(stringa, "(..)(.)\\1")
#Riconosci 3 lettere che si ripetono 
str_extract(stringa, "(...)\\1")
#Riconosci 1 lettera che si ripete dopo una lettera qualunque
str_extract(stringa, "(.)(.)\\1")
#Riconosci 2 lettere che si ripetono e un carattere qualunque prima
str_extract(stringa, "(.)(.)\\2")
#Riconosci tutte le sequenze dove prima e seconda lettera 
#si ripetono e la lettera successiva
str_extract(stringa, "(..)\\1")

```

---

<h2>Intro al <span>Ciclo For</span></h2>
<hr>
Il <mark>ciclo for</mark> è un'operazione che consente di ripetere una o più azioni un numero i di volte che  va da 1 a n dove n è scelto dall'utente/programmatore. <br>
Potenzialmente qualunque azione che va ripetuta n volte si può inserire in un <mark>ciclo for</mark>.<br>
In altri linguaggi di programmazione i <mark>for loop</mark> sono essenziali, ma il R non sono ottimizzati e se ne sconsiglia l'uso in favore delle <mark>apply functions</mark>.

<h3>Esempio <span>ciclo for</span></h3>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#Metodo inventato da me
vettore_stringa <- c("ciao", "mi", "chiamo", "Francesco")

vocali <- c('a', 'e', 'i', 'o', 'u')
vocali <- c(str_to_upper(vocali), vocali)
for (i in 1:length(vocali)){
  vettore_stringa <- str_replace(vettore_stringa, vocali[i], '*')
}

vettore_stringa
```

---

<h2>Ogni for loop vuole un <span>contenitore</span></h2>
<hr>
Quando si genera un oggetto da un <mark>for loop</mark> molto spesso questo va conservato. Lo svantaggio del ciclo for è che se non sappiamo quanti elementi si generano possiamo avere delle difficolta nell'immagazzinare ciò che il computer elabora!<br>
Immaginiamo di voler creare un frase per ogni studente che partecipa ad una competizione.<br>
Dopo aver raccolto i nomi in un vettore dovrò creare una lista dove immagazzinare le frasi che genererò con il <mark>for loop</mark>.
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
nomi

out <- vector("list", length = length(nomi))

for (i in 1:length(nomi)){
  out[i]<- paste("Lo studente numero", i, "si chiama", nomi[i])
}
unlist(out)
```
---

<h2>Simulazione con <span>for loop</span></h2>
<hr>
Immaginiamo di avere 500 valori di una variabile indipendente con distribuzione normale , *media* di valore 10 e *deviazione standard (sd)* di valore pari a 3.<br>
Immaginiamo ora che esista una proporzionalità quadratica tra la variabile indipendente e quella dipendente:<br>

$Y=\alpha X^2 + \beta X + c$<br>

R ci da la possibilità di generare sia numeri casuali, per esempio con la funzione <mark>runif()</mark>, sia la possibilità di generare vari tipi di distribuzioni.<br>
Per esempio spesso in natura si osservano distribuzioni che sono simili a quella normale.<br>
Per generare una distribuzione normale si usa il comando <mark>rnorm()</mark>.

---

<h2>Simulazione con <span>for loop</span></h2>
<hr>
Per simulare si possono usare le funzioni base di R.<br>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
# Definisco la variabile indipendente

set.seed(1234)#I risultati verranno sempre uguali
n = 500 #Numerosità
x <- rnorm(n = n, mean = 0, sd = 15) #Tipo di distribuzione
```


```{r eval=T, echo=T, message=TRUE, warning=TRUE}
# Definisco la variabile dipendente ed i parametri in modo casuale
set.seed(1234)
alpha = round(runif(1, 0.5, 1), 2) #Parametro alfa
beta = round(runif(1, 0, 1), 2) #Parametro beta
c = rnorm(n, mean = 100, sd = 50) #Definisco il rumore
y <- alpha*(x**2) + beta*x + c #Genero la variabile dipendente

#Creo un dataframe con i dati simulati
simulazione <- data.frame(x = x, y = y)
```

---

<h2>Gafico dati <span>simulati</span></h2>
<hr>

```{r eval=T, echo=T, message=TRUE, warning=TRUE}
# Definisco la variabile dipendente ed i parametri in modo casuale
plot(x, y, main = "Grafico dati simulati",
     xlab = "Variabile Indipendente",
     ylab = "Variabile Dipendente",
     xlim = c(min(x), max(x)),
     ylim = c(0, max(y)))
```

---

<div style="clear: none;" >
<div style="float: left; width: 48%;">

Se i dati raffigurati fossero reali ci si potrebbe aspettare una correlazione quadratica o cubica, ma si possono anche valutare altre possibilità.<br>
Nessuna correlazione:<br>
$Y=1 + c$<br>
Correlazione lineare:<br>
$Y=\alpha X + c$<br>
Correlazione quadratica:<br>
$Y=\alpha X^2 + \beta X + c$<br>
Correlazione cubica:<br>
$Y=\alpha X^3 + \beta X^2 + \gamma X + c$<br>
Correlazione logaritmica:<br>
$Y=ln(X) + c$<br>

</div>
<div style="float: right; width: 48%;">

```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#Definisco i nomi dei modelli 
#ed i modelli in un vettore
vettore_modelli <- 
  c('no_corr'="y~1", 
    'corr_lin'="y~x", 
    'corr_quad'="y~I(x^2)+x",
    'corr_cubica'="y~I(x^3)+I(x^2)+x",
    'corr_log'="y~log(abs(x))")
```


</div>
</div>

<h2>Creazione <span>modelli</span></h2>
<hr>



---

<h2>Creazione <span>modelli</span></h2>
<hr>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#Creo la lista per allocare le informazioni
modelli <- vector("list", length = length(vettore_modelli))

#Lancio un ciclo for per caricare il nome del modello e la sua 
#formula nella lista

for (i in seq_along(vettore_modelli)){
  modelli[i]<-vettore_modelli[i]
  names(modelli) <- names(vettore_modelli)
}

#I nomi degli elementi della lista possono essere visualizzati con la
#funzione names()
names(modelli)
```

---

<h2>Lancio il <span>ciclo for</span></h2>
<hr>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#Per ogni modello faccio una predizione su i dati della mia simulazione

for (i in seq_along(modelli)){
  #Lancio una simulazione per modello
  modelli[[i]]<- lm(vettore_modelli[i], data = simulazione)
  #Carico i dati ottenuti in un vettore v
  v <- predict(modelli[[i]], newdata = simulazione[, 1:2])
  #Incollo il vettore v nel dataframe
  simulazione <- cbind(simulazione,v)
  #Chiamo la nuova colonna come il nome del modello
  colnames(simulazione)[2+i] <- names(modelli[i])
  #Rimuovo il vettore v
  rm(v)
}
```

---

<h2>Risultato del <span>ciclo for</span></h2>
<hr>
```{r eval=T, echo=T, message=TRUE, warning=TRUE}
summary(simulazione)
```

---

<h2>Modificare il <span>Dataframe</span></h2>
<hr>
Ho creato così un dataframe che raccoglie i dati simulati e quelli predetti dai vari modelli.<br>
Un dataframe di questo tipo è facile da leggere ma non si può analizzare con un computer.<br>

```{r eval=T, echo=T, message=TRUE, warning=TRUE}
dim(simulazione)
head(simulazione, 2)
tail(simulazione, 2)
```

---

<h2>Creazione di un dataframe <span>"Tidy"</span></h2>
<hr>
In questo caso è utile sfruttare il pacchetto tydir.<br>

```{r eval=T, echo=T, message=TRUE, warning=TRUE}
#library(tidyverse) in particolare tydir::gather
new_sim <- simulazione %>% 
  gather(modello, predizione, -c(x, y))

new_sim$modello <- factor(new_sim$modello,
                          levels = c("no_corr",
                                     "corr_lin",
                                     "corr_quad",
                                     "corr_cubica",
                                     "corr_log"),
                          ordered = T)
dim(new_sim)

head(new_sim, 2)
tail(new_sim, 2)
```

---

<h2>Risultato in forma <span>grafica</span></h2>
<hr>

```{r eval=T, echo=T, message=TRUE, warning=F}
ggplot(new_sim , aes(x, y, color = modello))+
  geom_point(color = "black")+
  geom_line(aes(x = x, y = predizione), size = 1.5, alpha = 0.5)+
  scale_colour_hue()+
  labs(title = "Simulazione con ciclo for", 
       x = "Variabile indipendente", 
       y = "Variabile dipendente")+
  theme(plot.title = element_text(face = "bold"))
```
